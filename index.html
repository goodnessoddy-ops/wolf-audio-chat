<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Audio Chat - AI Powered</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: linear-gradient(135deg, #1a4d2e 0%, #2d5f3f 50%, #1a4d2e 100%);
            --bg-card: rgba(255,255,255,0.95);
            --text-primary: #000;
            --text-secondary: #666;
            --wolf-opacity: 0.2;
        }

        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #0a1f14 0%, #1a3322 50%, #0a1f14 100%);
            --bg-card: rgba(30,30,30,0.95);
            --text-primary: #fff;
            --text-secondary: #aaa;
            --wolf-opacity: 0.1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            position: relative;
            transition: background 0.3s ease;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }

        .wolf-bg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            height: 900px;
            opacity: var(--wolf-opacity);
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        @media (max-width: 768px) {
            .wolf-bg {
                width: 600px;
                height: 600px;
            }
        }

        .main-container {
            max-width: 900px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .title {
            text-align: center;
            color: white;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2em;
            }
        }

        .controls-panel {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .controls-panel {
                padding: 15px;
            }
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        @media (max-width: 768px) {
            .control-group {
                min-width: 100%;
            }
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #1a4d2e;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            color: #000;
            cursor: pointer;
        }

        [data-theme="dark"] .control-group select {
            background: #2a2a2a;
            color: #fff;
            border-color: #2d5f3f;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .icon-button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            background: #1a4d2e;
            color: white;
        }

        .icon-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .icon-button.active {
            background: #ff6b6b;
        }

        @media (max-width: 768px) {
            .icon-button {
                flex: 1;
                min-width: calc(50% - 5px);
            }
        }

        .giant-button {
            width: 100%;
            max-width: 600px;
            margin: 30px auto;
            padding: 40px 60px;
            font-size: 36px;
            font-weight: 900;
            text-align: center;
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
            border: 5px solid #fff;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 10px 40px rgba(0,255,0,0.5);
            display: block;
            transition: all 0.3s;
        }

        @media (max-width: 768px) {
            .giant-button {
                padding: 30px 40px;
                font-size: 24px;
            }
        }

        .giant-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 15px 50px rgba(0,255,0,0.7);
        }

        .giant-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .giant-button.stop-btn {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            box-shadow: 0 10px 40px rgba(255,0,0,0.5);
        }

        .giant-button:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .chat-box {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 30px;
            margin: 20px auto;
            max-width: 800px;
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .chat-box {
                padding: 15px;
                min-height: 300px;
                max-height: 400px;
            }
        }

        .message {
            padding: 15px 20px;
            margin: 10px 0;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            animation: slideIn 0.3s ease;
            line-height: 1.5;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-msg {
            background: linear-gradient(135deg, #1a4d2e 0%, #2d5f3f 100%);
            color: white;
            margin-left: auto;
        }

        .assistant-msg {
            background: #e0e0e0;
            color: #000;
        }

        [data-theme="dark"] .assistant-msg {
            background: #3a3a3a;
            color: #fff;
        }

        .interim-msg {
            background: #f0f0f0;
            color: #999;
            font-style: italic;
            border: 2px dashed #ccc;
            margin-left: auto;
        }

        [data-theme="dark"] .interim-msg {
            background: #2a2a2a;
            border-color: #555;
        }

        .status-bar {
            text-align: center;
            padding: 15px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            margin: 20px auto;
            max-width: 600px;
        }

        @media (max-width: 768px) {
            .status-bar {
                font-size: 16px;
                padding: 12px;
            }
        }

        [data-theme="dark"] .status-bar {
            background: rgba(30,30,30,0.9);
            color: #fff;
        }

        .listening {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .speaking {
            background: #fff9c4;
            color: #f57f17;
        }

        .thinking {
            background: #bbdefb;
            color: #1565c0;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .visualizer {
            display: none;
            height: 80px;
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            margin: 20px auto;
            max-width: 600px;
            overflow: hidden;
        }

        .visualizer.active {
            display: block;
        }

        .volume-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            transition: width 0.1s ease;
            border-radius: 15px;
        }

        .empty-msg {
            text-align: center;
            color: var(--text-secondary);
            padding: 50px;
            font-size: 18px;
            line-height: 1.6;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .close-button {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .telegram-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 999;
            display: none;
        }

        .telegram-button {
            background: linear-gradient(135deg, #0088cc 0%, #006699 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0, 136, 204, 0.5);
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }

        .telegram-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 136, 204, 0.7);
        }

        .telegram-button svg {
            width: 24px;
            height: 24px;
        }

        .telegram-user-info {
            background: linear-gradient(135deg, #0088cc 0%, #006699 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .game-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .game-container.active {
            display: flex;
        }

        .game-content {
            width: 90%;
            max-width: 500px;
            height: 80vh;
            background: var(--bg-card);
            border-radius: 20px;
            padding: 20px;
            position: relative;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .game-close {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        #gameCanvas {
            width: 100%;
            height: calc(100% - 60px);
            background: #87CEEB;
            border-radius: 10px;
            display: block;
        }

        .game-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
        }

        .game-menu-button {
            padding: 20px;
            background: linear-gradient(135deg, #1a4d2e 0%, #2d5f3f 100%);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .game-score {
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            color: var(--text-primary);
            margin: 10px 0;
        }

        .game-instructions {
            text-align: center;
            color: var(--text-secondary);
            margin: 10px 0;
            font-size: 14px;
        }


    </style>
</head>
<body>
    <svg class="wolf-bg" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
        <g fill="#ffffff">
            <ellipse cx="100" cy="80" rx="40" ry="45"/>
            <path d="M70 45 L60 20 Q58 15 63 13 Q68 12 72 18 L75 35 Z"/>
            <path d="M130 45 L140 20 Q142 15 137 13 Q132 12 128 18 L125 35 Z"/>
            <ellipse cx="100" cy="100" rx="25" ry="30"/>
            <circle cx="82" cy="75" r="9" fill="#000"/>
            <circle cx="84" cy="73" r="4" fill="#fff"/>
            <circle cx="118" cy="75" r="9" fill="#000"/>
            <circle cx="120" cy="73" r="4" fill="#fff"/>
            <ellipse cx="100" cy="105" rx="8" ry="10" fill="#000"/>
            <path d="M100 105 Q95 112 88 110 M100 105 Q105 112 112 110" stroke="#000" stroke-width="3" fill="none"/>
            <ellipse cx="100" cy="145" rx="45" ry="40"/>
            <rect x="65" y="165" width="15" height="50" rx="7"/>
            <rect x="120" y="165" width="15" height="50" rx="7"/>
        </g>
    </svg>

    <div class="main-container">
        <div id="telegramUserInfo" class="telegram-user-info" style="display: none;">
            üë§ <span id="telegramUsername"></span>
        </div>

        <h1 class="title">üê∫ WOLF AUDIO CHAT üê∫</h1>

        <div class="controls-panel">
            <div class="control-row">
                <div class="control-group">
                    <label for="modelSelect">‚ö° AI Model</label>
                    <select id="modelSelect">
                        <option value="llama-3.3-70b-versatile">‚ö° Fast</option>
                        <option value="llama-3.1-70b-versatile">‚öñÔ∏è Balanced</option>
                        <option value="mixtral-8x7b-32768">üß† Smart</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="personalitySelect">üé≠ Personality</label>
                    <select id="personalitySelect">
                        <option value="friendly">Friendly & Warm</option>
                        <option value="professional">Professional</option>
                        <option value="funny">Funny & Humorous</option>
                        <option value="serious">Serious & Direct</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="languageSelect">üåç Language</label>
                    <select id="languageSelect">
                        <option value="en-US">English (US)</option>
                        <option value="en-GB">English (UK)</option>
                        <option value="pcm-NG">Nigerian Pidgin</option>
                        <option value="yo-NG">Yoruba</option>
                        <option value="ig-NG">Igbo</option>
                        <option value="ha-NG">Hausa</option>
                        <option value="es-ES">Espa√±ol</option>
                        <option value="fr-FR">Fran√ßais</option>
                        <option value="de-DE">Deutsch</option>
                        <option value="it-IT">Italiano</option>
                        <option value="pt-BR">Portugu√™s</option>
                        <option value="ja-JP">Êó•Êú¨Ë™û</option>
                        <option value="zh-CN">‰∏≠Êñá</option>
                    </select>
                </div>
            </div>
            <div class="control-row">
                <div class="button-group">
                    <button class="icon-button" id="themeToggle">üåô Dark Mode</button>
                    <button class="icon-button" id="muteToggle">üîä Voice On</button>
                    <button class="icon-button" id="gamesButton">üéÆ Games</button>
                    <button class="icon-button" id="historyButton">üìù History</button>
                    <button class="icon-button" id="clearButton">üóëÔ∏è Clear Chat</button>
                </div>
            </div>
        </div>

        <div class="status-bar" id="statusBar">
            üê∫ Ready to chat - Click start below!
        </div>

        <div class="visualizer" id="visualizer">
            <div class="volume-bar" id="volumeBar"></div>
        </div>

        <button class="giant-button" id="startButton">
            üé§ START LISTENING üé§
        </button>

        <button class="giant-button stop-btn" id="stopButton" style="display: none;">
            üõë STOP üõë
        </button>

        <div class="chat-box" id="chatBox">
            <div class="empty-msg" id="emptyMsg">
                üê∫ Hello there! I'm Wolf, your AI companion!<br><br>
                Click "START LISTENING" and ask me anything you'd like.<br><br>
                <small style="color: var(--text-secondary);">I can answer questions, have natural conversations, and understand your emotions!</small>
            </div>
        </div>
    </div>

    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">üìù Conversation History</div>
                <button class="close-button" id="closeModal">&times;</button>
            </div>
            <div id="historyList"></div>
        </div>
    </div>

    <!-- Games Modal -->
    <div class="modal" id="gamesModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">üéÆ Games Menu</div>
                <button class="close-button" id="closeGamesModal">&times;</button>
            </div>
            <div class="game-menu">
                <button class="game-menu-button" id="playFlappyWolf">
                    üê∫ Flappy Wolf
                </button>
                <button class="game-menu-button" id="playSnakeGame">
                    üêç Snake Hunt
                </button>
                <button class="game-menu-button" id="playBrickBreaker">
                    üß± Wolf Brick Breaker
                </button>
                <button class="game-menu-button" id="playSpaceShooter">
                    üöÄ Space Wolf Shooter
                </button>
                <button class="game-menu-button" id="playWolfRun">
                    üèÉ Wolf Runner
                </button>
                <button class="game-menu-button" id="playMemoryMatch">
                    üß† Memory Match
                </button>
                <button class="game-menu-button" id="playWolfJump">
                    ü¶ò Wolf Jump
                </button>
                <button class="game-menu-button" id="playWolfCatch">
                    üéØ Catch the Prey
                </button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="gameContainer">
        <div class="game-content">
            <div class="game-header">
                <div class="game-title" id="currentGameTitle">üê∫ Flappy Wolf</div>
                <button class="game-close" id="closeGame">‚úï Close</button>
            </div>
            <div class="game-score" id="gameScore">Score: 0</div>
            <div class="game-instructions" id="gameInstructions">Tap or Space to flap!</div>
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <!-- Telegram Widget -->
    <div class="telegram-widget">
        <button class="telegram-button" id="telegramButton">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.562 8.161l-1.84 8.673c-.138.627-.5.781-.988.487l-2.733-2.012-1.318 1.267c-.146.146-.267.267-.548.267l.195-2.778 5.063-4.573c.219-.195-.048-.305-.341-.11l-6.258 3.942-2.697-.844c-.587-.182-.598-.587.122-.869l10.54-4.061c.488-.182.915.11.756.869z"/>
            </svg>
            Open in Telegram
        </button>
    </div>

    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script>
        // Telegram Mini App Integration
        let tg = null;
        let telegramUserId = null;
        let telegramUsername = null;

        // Check if running inside Telegram
        if (window.Telegram && window.Telegram.WebApp) {
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
            
            // Get user info from Telegram
            const user = tg.initDataUnsafe?.user;
            if (user) {
                telegramUserId = user.id;
                telegramUsername = user.username || user.first_name;
                
                // Display user info
                document.getElementById('telegramUserInfo').style.display = 'block';
                document.getElementById('telegramUsername').textContent = `Welcome, ${telegramUsername}!`;
            }
            
            // Hide the "Open in Telegram" button since we're already in Telegram
            document.querySelector('.telegram-widget').style.display = 'none';
            
            // Set Telegram theme colors
            const themeParams = tg.themeParams;
            if (themeParams.bg_color) {
                document.documentElement.style.setProperty('--bg-primary', themeParams.bg_color);
            }
            
            // Enable back button
            tg.BackButton.show();
            tg.BackButton.onClick(() => {
                tg.close();
            });
            
            // Main button for Telegram
            tg.MainButton.setText('Close App');
            tg.MainButton.show();
            tg.MainButton.onClick(() => {
                tg.close();
            });
            
        } else {
            // Not in Telegram - show the button
            document.querySelector('.telegram-widget').style.display = 'block';
        }

        // Telegram Button Click Handler (optional - for opening bot in Telegram)
        const telegramButton = document.getElementById('telegramButton');
        
        telegramButton.addEventListener('click', () => {
            // This button is hidden when app runs inside Telegram
            alert('Please set up your Telegram bot to use this feature.');
        });

        // IMPORTANT: Update this with your actual GitHub Pages or Render URL
        console.log('üê∫ Wolf Audio Chat Mini App Ready!');
        console.log('üìç Deploy this to GitHub Pages: https://yourusername.github.io/wolf-audio-chat');
        console.log('ü§ñ Then set in BotFather: /mybots ‚Üí Menu Button ‚Üí Paste your GitHub Pages URL');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusBar = document.getElementById('statusBar');
        const chatBox = document.getElementById('chatBox');
        const emptyMsg = document.getElementById('emptyMsg');
        const visualizer = document.getElementById('visualizer');
        const volumeBar = document.getElementById('volumeBar');
        const modelSelect = document.getElementById('modelSelect');
        const personalitySelect = document.getElementById('personalitySelect');
        const languageSelect = document.getElementById('languageSelect');
        const themeToggle = document.getElementById('themeToggle');
        const muteToggle = document.getElementById('muteToggle');
        const historyButton = document.getElementById('historyButton');
        const clearButton = document.getElementById('clearButton');
        const historyModal = document.getElementById('historyModal');
        const closeModal = document.getElementById('closeModal');
        const historyList = document.getElementById('historyList');
        const gamesButton = document.getElementById('gamesButton');
        const gamesModal = document.getElementById('gamesModal');
        const closeGamesModal = document.getElementById('closeGamesModal');
        const gameContainer = document.getElementById('gameContainer');
        const closeGame = document.getElementById('closeGame');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const gameScore = document.getElementById('gameScore');
        const currentGameTitle = document.getElementById('currentGameTitle');
        const gameInstructions = document.getElementById('gameInstructions');
        const playFlappyWolf = document.getElementById('playFlappyWolf');
        const playSnakeGame = document.getElementById('playSnakeGame');
        const playBrickBreaker = document.getElementById('playBrickBreaker');
        const playSpaceShooter = document.getElementById('playSpaceShooter');
        const playWolfRun = document.getElementById('playWolfRun');
        const playMemoryMatch = document.getElementById('playMemoryMatch');
        const playWolfJump = document.getElementById('playWolfJump');
        const playWolfCatch = document.getElementById('playWolfCatch');

        // Backend API endpoint
        const API_ENDPOINT = 'https://wolf-audio-chat.onrender.com/api/chat';

        let recognition;
        let synthesis = window.speechSynthesis;
        let isListening = false;
        let interimElement = null;
        let conversationHistory = [];
        let audioContext;
        let analyser;
        let microphone;
        let isMuted = false;
        let savedConversations = JSON.parse(localStorage.getItem('wolfConversations') || '[]');

        const personalities = {
            friendly: 'You are Wolf, a warm, friendly, and highly articulate AI voice assistant. Keep your answers concise (2-3 sentences) since they\'ll be read aloud. Use perfect, fluent English with natural flow. Be empathetic and genuinely interested in helping.',
            professional: 'You are Wolf, a professional and efficient AI assistant. Provide clear, concise information in a business-like tone. Keep responses brief (2-3 sentences).',
            funny: 'You are Wolf, a witty and humorous AI assistant. Make conversations fun with clever jokes. Keep it light (2-3 sentences) but always helpful.',
            serious: 'You are Wolf, a serious and direct AI assistant. Provide straightforward, factual responses. Be concise (2-3 sentences), precise, and to the point.'
        };

        const languageNames = {
            'en-US': 'English', 'en-GB': 'English',
            'es-ES': 'Spanish', 'fr-FR': 'French', 'de-DE': 'German',
            'it-IT': 'Italian', 'pt-BR': 'Portuguese', 'ja-JP': 'Japanese', 'zh-CN': 'Chinese'
        };

        const savedTheme = localStorage.getItem('wolfTheme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        themeToggle.textContent = savedTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';

        themeToggle.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const newTheme = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('wolfTheme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
        });

        muteToggle.addEventListener('click', () => {
            isMuted = !isMuted;
            muteToggle.textContent = isMuted ? 'üîá Voice Off' : 'üîä Voice On';
            muteToggle.classList.toggle('active');
        });

        clearButton.addEventListener('click', () => {
            if (confirm('Clear current conversation?')) {
                conversationHistory = [];
                chatBox.innerHTML = '<div class="empty-msg">üê∫ Chat cleared!</div>';
            }
        });

        historyButton.addEventListener('click', () => {
            displayHistory();
            historyModal.classList.add('active');
        });

        closeModal.addEventListener('click', () => historyModal.classList.remove('active'));
        historyModal.addEventListener('click', (e) => {
            if (e.target === historyModal) historyModal.classList.remove('active');
        });

        gamesButton.addEventListener('click', () => {
            gamesModal.classList.add('active');
        });

        closeGamesModal.addEventListener('click', () => gamesModal.classList.remove('active'));
        gamesModal.addEventListener('click', (e) => {
            if (e.target === gamesModal) gamesModal.classList.remove('active');
        });

        closeGame.addEventListener('click', () => {
            gameContainer.classList.remove('active');
            if (currentGame) currentGame.stop();
        });

        let currentGame = null;

        // Flappy Wolf Game
        playFlappyWolf.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üê∫ Flappy Wolf';
            gameInstructions.textContent = 'Tap or Space to flap!';
            startFlappyWolf();
        });

        // Snake Game
        playSnakeGame.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üêç Snake Hunt';
            gameInstructions.textContent = 'Arrow keys to move!';
            startSnakeGame();
        });

        // Brick Breaker Game
        playBrickBreaker.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üß± Wolf Brick Breaker';
            gameInstructions.textContent = 'Move mouse or touch to control paddle!';
            startBrickBreaker();
        });

        // Space Shooter Game
        playSpaceShooter.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üöÄ Space Wolf Shooter';
            gameInstructions.textContent = 'Arrow keys to move, Space to shoot!';
            startSpaceShooter();
        });

        // Wolf Runner Game
        playWolfRun.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üèÉ Wolf Runner';
            gameInstructions.textContent = 'Space or tap to jump over obstacles!';
            startWolfRunner();
        });

        // Memory Match Game
        playMemoryMatch.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üß† Memory Match';
            gameInstructions.textContent = 'Click cards to find matching pairs!';
            startMemoryMatch();
        });

        // Wolf Jump Game
        playWolfJump.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'ü¶ò Wolf Jump';
            gameInstructions.textContent = 'Jump left/right to climb higher!';
            startWolfJump();
        });

        // Wolf Catch Game
        playWolfCatch.addEventListener('click', () => {
            gamesModal.classList.remove('active');
            gameContainer.classList.add('active');
            currentGameTitle.textContent = 'üéØ Catch the Prey';
            gameInstructions.textContent = 'Move mouse/touch to catch falling prey!';
            startWolfCatch();
        });

        function startFlappyWolf() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const wolf = {
                x: 80,
                y: gameCanvas.height / 2,
                velocity: 0,
                gravity: 0.5,
                jump: -10,
                size: 30
            };

            const pipes = [];
            let score = 0;
            let frame = 0;
            let gameRunning = true;

            function createPipe() {
                const gap = 150;
                const minHeight = 50;
                const maxHeight = gameCanvas.height - gap - minHeight;
                const height = Math.random() * (maxHeight - minHeight) + minHeight;
                
                pipes.push({
                    x: gameCanvas.width,
                    topHeight: height,
                    bottomY: height + gap,
                    width: 50,
                    scored: false
                });
            }

            function jump() {
                if (gameRunning) {
                    wolf.velocity = wolf.jump;
                }
            }

            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && gameContainer.classList.contains('active')) {
                    e.preventDefault();
                    jump();
                }
            });

            gameCanvas.addEventListener('click', jump);
            gameCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                jump();
            });

            function gameLoop() {
                if (!gameRunning) return;

                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Update wolf
                wolf.velocity += wolf.gravity;
                wolf.y += wolf.velocity;

                // Draw wolf
                ctx.save();
                ctx.translate(wolf.x, wolf.y);
                
                // Wolf body
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.ellipse(0, 0, wolf.size, wolf.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf head
                ctx.fillStyle = '#A0826D';
                ctx.beginPath();
                ctx.arc(-8, -wolf.size * 0.5, wolf.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf snout
                ctx.fillStyle = '#C9B8A8';
                ctx.beginPath();
                ctx.ellipse(-15, -wolf.size * 0.4, wolf.size * 0.4, wolf.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf ears (pointed)
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.moveTo(-8, -wolf.size * 0.9);
                ctx.lineTo(-2, -wolf.size * 1.2);
                ctx.lineTo(2, -wolf.size * 0.9);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(-14, -wolf.size * 0.9);
                ctx.lineTo(-18, -wolf.size * 1.2);
                ctx.lineTo(-12, -wolf.size * 0.9);
                ctx.closePath();
                ctx.fill();
                
                // Wolf eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-12, -wolf.size * 0.6, 4, 0, Math.PI * 2);
                ctx.arc(-4, -wolf.size * 0.6, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-12, -wolf.size * 0.6, 2, 0, Math.PI * 2);
                ctx.arc(-4, -wolf.size * 0.6, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf nose
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-18, -wolf.size * 0.4, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf tail
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(wolf.size * 0.6, 0);
                ctx.quadraticCurveTo(wolf.size * 1.2, -10, wolf.size * 1.0, -20);
                ctx.stroke();
                
                // Tail tip
                ctx.fillStyle = '#D3D3D3';
                ctx.beginPath();
                ctx.arc(wolf.size * 1.0, -20, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();

                // Create pipes
                frame++;
                if (frame % 120 === 0) {
                    createPipe();
                }

                // Update and draw pipes
                for (let i = pipes.length - 1; i >= 0; i--) {
                    const pipe = pipes[i];
                    pipe.x -= 3;

                    // Draw pipes
                    ctx.fillStyle = '#2d5f3f';
                    ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                    ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, gameCanvas.height - pipe.bottomY);

                    // Check collision
                    if (wolf.x + wolf.size > pipe.x && 
                        wolf.x - wolf.size < pipe.x + pipe.width) {
                        if (wolf.y - wolf.size < pipe.topHeight || 
                            wolf.y + wolf.size > pipe.bottomY) {
                            gameRunning = false;
                            gameOver();
                        }
                    }

                    // Score
                    if (!pipe.scored && pipe.x + pipe.width < wolf.x) {
                        score++;
                        pipe.scored = true;
                        gameScore.textContent = `Score: ${score}`;
                    }

                    // Remove off-screen pipes
                    if (pipe.x + pipe.width < 0) {
                        pipes.splice(i, 1);
                    }
                }

                // Check boundaries
                if (wolf.y + wolf.size > gameCanvas.height || wolf.y - wolf.size < 0) {
                    gameRunning = false;
                    gameOver();
                }

                if (gameRunning) {
                    requestAnimationFrame(gameLoop);
                }
            }

            function gameOver() {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                gameCanvas.onclick = () => {
                    pipes.length = 0;
                    score = 0;
                    frame = 0;
                    wolf.y = gameCanvas.height / 2;
                    wolf.velocity = 0;
                    gameRunning = true;
                    gameScore.textContent = 'Score: 0';
                    gameLoop();
                };
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                }
            };

            gameScore.textContent = 'Score: 0';
            gameLoop();
        }

        function startSnakeGame() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const gridSize = 20;
            const tileCount = Math.floor(gameCanvas.width / gridSize);
            const tileCountY = Math.floor(gameCanvas.height / gridSize);

            let snake = [{x: 10, y: 10}];
            let dx = 1;
            let dy = 0;
            let food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCountY)
            };
            let score = 0;
            let gameRunning = true;
            let speed = 150;
            let lastTime = Date.now();

            function changeDirection(e) {
                const key = e.key;
                if (key === 'ArrowUp' && dy === 0) { dx = 0; dy = -1; }
                if (key === 'ArrowDown' && dy === 0) { dx = 0; dy = 1; }
                if (key === 'ArrowLeft' && dx === 0) { dx = -1; dy = 0; }
                if (key === 'ArrowRight' && dx === 0) { dx = 1; dy = 0; }
            }

            const keyHandler = (e) => {
                if (gameContainer.classList.contains('active') && 
                    currentGameTitle.textContent === 'üêç Snake Hunt') {
                    changeDirection(e);
                }
            };

            document.addEventListener('keydown', keyHandler);

            function update() {
                if (!gameRunning) return;

                const now = Date.now();
                if (now - lastTime < speed) {
                    requestAnimationFrame(update);
                    return;
                }
                lastTime = now;

                // Move snake
                const head = {x: snake[0].x + dx, y: snake[0].y + dy};

                // Check wall collision
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCountY) {
                    gameOver();
                    return;
                }

                // Check self collision
                for (let segment of snake) {
                    if (head.x === segment.x && head.y === segment.y) {
                        gameOver();
                        return;
                    }
                }

                snake.unshift(head);

                // Check food
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    gameScore.textContent = `Score: ${score}`;
                    food = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    speed = Math.max(50, speed - 3);
                } else {
                    snake.pop();
                }

                draw();
                requestAnimationFrame(update);
            }

            function draw() {
                // Background
                ctx.fillStyle = '#2d5f3f';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Draw grid pattern
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x < tileCount; x++) {
                    for (let y = 0; y < tileCountY; y++) {
                        ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
                    }
                }

                // Draw snake with realistic look
                for (let i = 0; i < snake.length; i++) {
                    const segment = snake[i];
                    const isHead = i === 0;
                    
                    if (isHead) {
                        // Snake head
                        ctx.save();
                        ctx.translate(segment.x * gridSize + gridSize/2, segment.y * gridSize + gridSize/2);
                        
                        // Rotate based on direction
                        let angle = 0;
                        if (dx === 1) angle = 0;
                        if (dx === -1) angle = Math.PI;
                        if (dy === 1) angle = Math.PI / 2;
                        if (dy === -1) angle = -Math.PI / 2;
                        ctx.rotate(angle);
                        
                        // Head shape
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, gridSize/2, gridSize/2.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Eyes
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(-3, -4, 2.5, 0, Math.PI * 2);
                        ctx.arc(3, -4, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(-3, -4, 1.5, 0, Math.PI * 2);
                        ctx.arc(3, -4, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Tongue
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.lineTo(12, -2);
                        ctx.moveTo(8, 0);
                        ctx.lineTo(12, 2);
                        ctx.stroke();
                        
                        // Nostrils
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(6, -1, 1, 0, Math.PI * 2);
                        ctx.arc(6, 1, 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    } else {
                        // Body segments with pattern
                        ctx.fillStyle = `rgb(34, ${Math.min(139, 139 - i * 2)}, 34)`;
                        ctx.beginPath();
                        ctx.arc(segment.x * gridSize + gridSize/2, segment.y * gridSize + gridSize/2, gridSize/2 - 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Scale pattern
                        if (i % 2 === 0) {
                            ctx.fillStyle = `rgba(50, 205, 50, 0.3)`;
                            ctx.beginPath();
                            ctx.arc(segment.x * gridSize + gridSize/2, segment.y * gridSize + gridSize/2, gridSize/3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                // Draw food (apple)
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Apple shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(food.x * gridSize + gridSize/2 - 2, food.y * gridSize + gridSize/2 - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Apple stem
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(food.x * gridSize + gridSize/2, food.y * gridSize + 2);
                ctx.lineTo(food.x * gridSize + gridSize/2, food.y * gridSize - 2);
                ctx.stroke();
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Press any key to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                const restartHandler = (e) => {
                    document.removeEventListener('keydown', restartHandler);
                    document.removeEventListener('keydown', keyHandler);
                    snake = [{x: 10, y: 10}];
                    dx = 1;
                    dy = 0;
                    score = 0;
                    speed = 150;
                    gameRunning = true;
                    gameScore.textContent = 'Score: 0';
                    food = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    startSnakeGame();
                };
                
                document.addEventListener('keydown', restartHandler);
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    document.removeEventListener('keydown', keyHandler);
                }
            };

            gameScore.textContent = 'Score: 0';
            draw();
            update();
        }

        function startBrickBreaker() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const paddleWidth = 100;
            const paddleHeight = 15;
            let paddleX = gameCanvas.width / 2 - paddleWidth / 2;

            const ball = {
                x: gameCanvas.width / 2,
                y: gameCanvas.height - 40,
                radius: 8,
                dx: 4,
                dy: -4
            };

            const brickRowCount = 5;
            const brickColumnCount = 8;
            const brickWidth = 60;
            const brickHeight = 20;
            const brickPadding = 5;
            const brickOffsetTop = 50;
            const brickOffsetLeft = 30;

            const bricks = [];
            const brickColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'];
            
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }

            let score = 0;
            let gameRunning = true;

            function mouseMoveHandler(e) {
                const rect = gameCanvas.getBoundingClientRect();
                const relativeX = e.clientX - rect.left;
                if (relativeX > 0 && relativeX < gameCanvas.width) {
                    paddleX = relativeX - paddleWidth / 2;
                }
            }

            function touchMoveHandler(e) {
                e.preventDefault();
                const rect = gameCanvas.getBoundingClientRect();
                const relativeX = e.touches[0].clientX - rect.left;
                if (relativeX > 0 && relativeX < gameCanvas.width) {
                    paddleX = relativeX - paddleWidth / 2;
                }
            }

            gameCanvas.addEventListener('mousemove', mouseMoveHandler);
            gameCanvas.addEventListener('touchmove', touchMoveHandler);

            function collisionDetection() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        const b = bricks[c][r];
                        if (b.status === 1) {
                            if (ball.x > b.x && ball.x < b.x + brickWidth && 
                                ball.y > b.y && ball.y < b.y + brickHeight) {
                                ball.dy = -ball.dy;
                                b.status = 0;
                                score++;
                                gameScore.textContent = `Score: ${score}`;
                                
                                if (score === brickRowCount * brickColumnCount) {
                                    gameWin();
                                }
                            }
                        }
                    }
                }
            }

            function drawBall() {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();
                ctx.closePath();
            }

            function drawPaddle() {
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(paddleX, gameCanvas.height - paddleHeight - 10, paddleWidth, paddleHeight);
                
                // Paddle details
                ctx.fillStyle = '#A0826D';
                ctx.fillRect(paddleX + 5, gameCanvas.height - paddleHeight - 10, paddleWidth - 10, paddleHeight - 5);
            }

            function drawBricks() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        if (bricks[c][r].status === 1) {
                            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                            bricks[c][r].x = brickX;
                            bricks[c][r].y = brickY;
                            
                            ctx.fillStyle = brickColors[r];
                            ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
                            
                            // Brick highlight
                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.fillRect(brickX, brickY, brickWidth, brickHeight / 2);
                        }
                    }
                }
            }

            function draw() {
                if (!gameRunning) return;

                ctx.fillStyle = '#1a4d2e';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                drawBricks();
                drawBall();
                drawPaddle();
                collisionDetection();

                // Ball physics
                if (ball.x + ball.dx > gameCanvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
                    ball.dx = -ball.dx;
                }
                if (ball.y + ball.dy < ball.radius) {
                    ball.dy = -ball.dy;
                } else if (ball.y + ball.dy > gameCanvas.height - ball.radius - paddleHeight - 10) {
                    if (ball.x > paddleX && ball.x < paddleX + paddleWidth) {
                        ball.dy = -ball.dy;
                        // Add spin based on where ball hits paddle
                        const hitPos = (ball.x - paddleX) / paddleWidth;
                        ball.dx = (hitPos - 0.5) * 8;
                    } else if (ball.y + ball.dy > gameCanvas.height - ball.radius) {
                        gameOver();
                        return;
                    }
                }

                ball.x += ball.dx;
                ball.y += ball.dy;

                requestAnimationFrame(draw);
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                gameCanvas.onclick = () => startBrickBreaker();
            }

            function gameWin() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,255,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('You Win! üéâ', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Perfect Score: ${score}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to play again', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                gameCanvas.onclick = () => startBrickBreaker();
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    gameCanvas.removeEventListener('mousemove', mouseMoveHandler);
                    gameCanvas.removeEventListener('touchmove', touchMoveHandler);
                }
            };

            gameScore.textContent = 'Score: 0';
            draw();
        }

        function startSpaceShooter() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const player = {
                x: gameCanvas.width / 2,
                y: gameCanvas.height - 60,
                width: 40,
                height: 40,
                speed: 5
            };

            const keys = {};
            const bullets = [];
            const enemies = [];
            let score = 0;
            let gameRunning = true;
            let enemySpawnTimer = 0;

            function keyDownHandler(e) {
                keys[e.key] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shootBullet();
                }
            }

            function keyUpHandler(e) {
                keys[e.key] = false;
            }

            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);

            function shootBullet() {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 15,
                    speed: 7
                });
            }

            function createEnemy() {
                enemies.push({
                    x: Math.random() * (gameCanvas.width - 30),
                    y: -30,
                    width: 30,
                    height: 30,
                    speed: 2 + Math.random() * 2
                });
            }

            function drawPlayer() {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                
                // Wolf spaceship body
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(-15, 20);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.fill();
                
                // Wolf face on ship
                ctx.fillStyle = '#A0826D';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-4, -2, 3, 0, Math.PI * 2);
                ctx.arc(4, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-4, -2, 2, 0, Math.PI * 2);
                ctx.arc(4, -2, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Engines
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(-12, 15, 6, 8);
                ctx.fillRect(6, 15, 6, 8);
                
                ctx.restore();
            }

            function update() {
                if (!gameRunning) return;

                // Clear canvas
                ctx.fillStyle = '#000033';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Draw stars
                ctx.fillStyle = 'white';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 37) % gameCanvas.width;
                    const y = (i * 41 + Date.now() / 10) % gameCanvas.height;
                    ctx.fillRect(x, y, 2, 2);
                }

                // Player movement
                if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
                if (keys['ArrowRight'] && player.x < gameCanvas.width - player.width) player.x += player.speed;
                if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
                if (keys['ArrowDown'] && player.y < gameCanvas.height - player.height) player.y += player.speed;

                drawPlayer();

                // Update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.y -= bullet.speed;
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    
                    if (bullet.y < 0) bullets.splice(i, 1);
                }

                // Spawn enemies
                enemySpawnTimer++;
                if (enemySpawnTimer > 60) {
                    createEnemy();
                    enemySpawnTimer = 0;
                }

                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    enemy.y += enemy.speed;
                    
                    // Draw enemy (alien ship)
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width / 2 - 5, enemy.y + enemy.height / 2 - 3, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.x + enemy.width / 2 + 5, enemy.y + enemy.height / 2 - 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Check collision with bullets
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const bullet = bullets[j];
                        if (bullet.x < enemy.x + enemy.width &&
                            bullet.x + bullet.width > enemy.x &&
                            bullet.y < enemy.y + enemy.height &&
                            bullet.y + bullet.height > enemy.y) {
                            enemies.splice(i, 1);
                            bullets.splice(j, 1);
                            score += 10;
                            gameScore.textContent = `Score: ${score}`;
                            break;
                        }
                    }
                    
                    // Check collision with player
                    if (enemy.x < player.x + player.width &&
                        enemy.x + enemy.width > player.x &&
                        enemy.y < player.y + player.height &&
                        enemy.y + enemy.height > player.y) {
                        gameOver();
                        return;
                    }
                    
                    if (enemy.y > gameCanvas.height) enemies.splice(i, 1);
                }

                requestAnimationFrame(update);
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Final Score: ${score}`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                gameCanvas.onclick = () => startSpaceShooter();
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    document.removeEventListener('keydown', keyDownHandler);
                    document.removeEventListener('keyup', keyUpHandler);
                }
            };

            gameScore.textContent = 'Score: 0';
            update();
        }

        function startWolfRunner() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const wolf = {
                x: 80,
                y: gameCanvas.height - 80,
                width: 40,
                height: 40,
                velocityY: 0,
                gravity: 0.8,
                jumpPower: -15,
                grounded: true
            };

            const obstacles = [];
            let score = 0;
            let gameRunning = true;
            let gameSpeed = 5;
            let obstacleTimer = 0;
            let groundY = gameCanvas.height - 40;

            function jump() {
                if (wolf.grounded) {
                    wolf.velocityY = wolf.jumpPower;
                    wolf.grounded = false;
                }
            }

            function keyHandler(e) {
                if (e.code === 'Space' && gameContainer.classList.contains('active')) {
                    e.preventDefault();
                    jump();
                }
            }

            document.addEventListener('keydown', keyHandler);
            gameCanvas.addEventListener('click', jump);
            gameCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                jump();
            });

            function createObstacle() {
                const types = ['rock', 'tree', 'cactus'];
                const type = types[Math.floor(Math.random() * types.length)];
                obstacles.push({
                    x: gameCanvas.width,
                    y: groundY - 30,
                    width: 30,
                    height: 30,
                    type: type
                });
            }

            function drawWolfRunner() {
                ctx.save();
                ctx.translate(wolf.x + wolf.width / 2, wolf.y + wolf.height / 2);
                
                // Running animation
                const legOffset = Math.sin(Date.now() / 100) * 5;
                
                // Wolf body (facing forward)
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(-15, -5, 30, 25);
                
                // Wolf head (facing forward)
                ctx.fillStyle = '#A0826D';
                ctx.beginPath();
                ctx.arc(0, -15, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Wolf snout (centered, facing forward)
                ctx.fillStyle = '#C9B8A8';
                ctx.fillRect(-8, -8, 16, 12);
                
                // Eyes (both visible, facing forward)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-6, -18, 4, 0, Math.PI * 2);
                ctx.arc(6, -18, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-6, -18, 2, 0, Math.PI * 2);
                ctx.arc(6, -18, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose (centered)
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(0, -8, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-4, -5);
                ctx.quadraticCurveTo(0, -3, 4, -5);
                ctx.stroke();
                
                // Ears (both visible, pointed up)
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.moveTo(-10, -28);
                ctx.lineTo(-6, -35);
                ctx.lineTo(-2, -28);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(2, -28);
                ctx.lineTo(6, -35);
                ctx.lineTo(10, -28);
                ctx.closePath();
                ctx.fill();
                
                // Front legs (both visible, running animation)
                ctx.fillStyle = '#6B5345';
                ctx.fillRect(-12, 15, 8, 18 + legOffset);
                ctx.fillRect(4, 15, 8, 18 - legOffset);
                
                // Tail (behind, sticking up)
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(0, 15);
                ctx.quadraticCurveTo(0, 30, -5, 35);
                ctx.stroke();
                
                // Tail tip
                ctx.fillStyle = '#D3D3D3';
                ctx.beginPath();
                ctx.arc(-5, 35, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            function drawObstacle(obstacle) {
                if (obstacle.type === 'rock') {
                    ctx.fillStyle = '#666666';
                    ctx.beginPath();
                    ctx.arc(obstacle.x + 15, obstacle.y + 15, 15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.arc(obstacle.x + 10, obstacle.y + 10, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'tree') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(obstacle.x + 10, obstacle.y, 10, 30);
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(obstacle.x + 15, obstacle.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obstacle.type === 'cactus') {
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(obstacle.x + 12, obstacle.y + 10, 6, 20);
                    ctx.fillRect(obstacle.x + 8, obstacle.y + 15, 4, 10);
                    ctx.fillRect(obstacle.x + 18, obstacle.y + 15, 4, 10);
                }
            }

            function update() {
                if (!gameRunning) return;

                // Clear and draw background
                const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#90EE90');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Draw ground
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(0, groundY, gameCanvas.width, gameCanvas.height - groundY);
                
                // Ground details
                ctx.fillStyle = '#6B5345';
                for (let i = 0; i < gameCanvas.width; i += 20) {
                    ctx.fillRect(i - (Date.now() / 10) % 20, groundY, 10, 5);
                }

                // Wolf physics
                wolf.velocityY += wolf.gravity;
                wolf.y += wolf.velocityY;

                if (wolf.y >= groundY - wolf.height) {
                    wolf.y = groundY - wolf.height;
                    wolf.velocityY = 0;
                    wolf.grounded = true;
                }

                drawWolfRunner();

                // Create obstacles
                obstacleTimer++;
                if (obstacleTimer > 100 - gameSpeed) {
                    createObstacle();
                    obstacleTimer = 0;
                }

                // Update obstacles
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.x -= gameSpeed;

                    drawObstacle(obstacle);

                    // Check collision
                    if (wolf.x < obstacle.x + obstacle.width &&
                        wolf.x + wolf.width > obstacle.x &&
                        wolf.y < obstacle.y + obstacle.height &&
                        wolf.y + wolf.height > obstacle.y) {
                        gameOver();
                        return;
                    }

                    // Score point
                    if (obstacle.x + obstacle.width < wolf.x && !obstacle.scored) {
                        obstacle.scored = true;
                        score++;
                        gameScore.textContent = `Score: ${score}`;
                        
                        if (score % 10 === 0) {
                            gameSpeed += 0.5;
                        }
                    }

                    if (obstacle.x + obstacle.width < 0) {
                        obstacles.splice(i, 1);
                    }
                }

                // Draw score
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(`Distance: ${score}m`, 10, 30);

                requestAnimationFrame(update);
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Distance: ${score}m`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                const restartHandler = () => {
                    gameCanvas.removeEventListener('click', restartHandler);
                    startWolfRunner();
                };
                gameCanvas.addEventListener('click', restartHandler);
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    document.removeEventListener('keydown', keyHandler);
                }
            };

            gameScore.textContent = 'Score: 0';
            update();
        }

        function startMemoryMatch() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const symbols = ['üê∫', 'üåô', 'üå≤', 'ü¶ä', 'üêæ', '‚≠ê', 'üåø', 'üèîÔ∏è'];
            const cards = [...symbols, ...symbols].sort(() => Math.random() - 0.5);
            
            const cardWidth = 70;
            const cardHeight = 90;
            const padding = 10;
            const cols = 4;
            const rows = 4;
            
            const startX = (gameCanvas.width - (cols * (cardWidth + padding))) / 2;
            const startY = 50;

            const gameCards = cards.map((symbol, index) => ({
                symbol,
                x: startX + (index % cols) * (cardWidth + padding),
                y: startY + Math.floor(index / cols) * (cardHeight + padding),
                width: cardWidth,
                height: cardHeight,
                flipped: false,
                matched: false
            }));

            let firstCard = null;
            let secondCard = null;
            let canFlip = true;
            let matches = 0;
            let moves = 0;
            let gameRunning = true;

            function drawCards() {
                ctx.fillStyle = '#1a4d2e';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                for (const card of gameCards) {
                    if (card.matched) {
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillRect(card.x, card.y, card.width, card.height);
                        ctx.strokeStyle = '#2E7D32';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(card.x, card.y, card.width, card.height);
                        
                        ctx.font = '40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(card.symbol, card.x + card.width / 2, card.y + card.height / 2);
                    } else if (card.flipped) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(card.x, card.y, card.width, card.height);
                        ctx.strokeStyle = '#2d5f3f';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(card.x, card.y, card.width, card.height);
                        
                        ctx.font = '40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(card.symbol, card.x + card.width / 2, card.y + card.height / 2);
                    } else {
                        ctx.fillStyle = '#2d5f3f';
                        ctx.fillRect(card.x, card.y, card.width, card.height);
                        ctx.strokeStyle = '#1a4d2e';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(card.x, card.y, card.width, card.height);
                        
                        // Wolf pattern on back
                        ctx.fillStyle = '#1a4d2e';
                        ctx.font = '30px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üê∫', card.x + card.width / 2, card.y + card.height / 2);
                    }
                }

                // Draw stats
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Moves: ${moves}`, 10, 25);
                ctx.fillText(`Matches: ${matches}/8`, 10, 50);
            }

            function handleClick(e) {
                if (!canFlip || !gameRunning) return;

                const rect = gameCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                for (const card of gameCards) {
                    if (x >= card.x && x <= card.x + card.width &&
                        y >= card.y && y <= card.y + card.height &&
                        !card.flipped && !card.matched) {
                        
                        card.flipped = true;
                        
                        if (!firstCard) {
                            firstCard = card;
                        } else if (!secondCard) {
                            secondCard = card;
                            moves++;
                            canFlip = false;

                            setTimeout(() => {
                                if (firstCard.symbol === secondCard.symbol) {
                                    firstCard.matched = true;
                                    secondCard.matched = true;
                                    matches++;
                                    
                                    if (matches === 8) {
                                        gameWin();
                                    }
                                } else {
                                    firstCard.flipped = false;
                                    secondCard.flipped = false;
                                }
                                
                                firstCard = null;
                                secondCard = null;
                                canFlip = true;
                                drawCards();
                            }, 1000);
                        }
                        
                        drawCards();
                        break;
                    }
                }
            }

            function handleTouch(e) {
                e.preventDefault();
                const rect = gameCanvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                handleClick(fakeEvent);
            }

            gameCanvas.addEventListener('click', handleClick);
            gameCanvas.addEventListener('touchstart', handleTouch);

            function gameWin() {
                gameRunning = false;
                setTimeout(() => {
                    ctx.fillStyle = 'rgba(0,255,0,0.9)';
                    ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('You Win! üéâ', gameCanvas.width / 2, gameCanvas.height / 2 - 40);
                    ctx.font = '24px Arial';
                    ctx.fillText(`Completed in ${moves} moves!`, gameCanvas.width / 2, gameCanvas.height / 2);
                    ctx.fillText('Click to play again', gameCanvas.width / 2, gameCanvas.height / 2 + 40);
                    
                    const restartHandler = () => {
                        gameCanvas.removeEventListener('click', restartHandler);
                        startMemoryMatch();
                    };
                    gameCanvas.addEventListener('click', restartHandler);
                }, 500);
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    gameCanvas.removeEventListener('click', handleClick);
                    gameCanvas.removeEventListener('touchstart', handleTouch);
                }
            };

            gameScore.textContent = 'Moves: 0';
            drawCards();
        }

        function startWolfJump() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const wolf = {
                x: gameCanvas.width / 2,
                y: gameCanvas.height - 100,
                width: 40,
                height: 40,
                velocityX: 0,
                velocityY: 0,
                jumping: false
            };

            const platforms = [];
            let cameraY = 0;
            let score = 0;
            let highestY = wolf.y;
            let gameRunning = true;

            // Create initial platforms
            for (let i = 0; i < 15; i++) {
                platforms.push({
                    x: Math.random() * (gameCanvas.width - 80),
                    y: gameCanvas.height - i * 60,
                    width: 80,
                    height: 15,
                    type: Math.random() > 0.8 ? 'moving' : 'static',
                    direction: Math.random() > 0.5 ? 1 : -1
                });
            }

            function keyHandler(e) {
                if (e.key === 'ArrowLeft') {
                    wolf.velocityX = -7;
                } else if (e.key === 'ArrowRight') {
                    wolf.velocityX = 7;
                }
            }

            document.addEventListener('keydown', keyHandler);

            function drawWolf() {
                ctx.save();
                ctx.translate(wolf.x, wolf.y - cameraY);
                
                // Wolf body (facing forward)
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(-15, -5, 30, 25);
                
                // Head
                ctx.fillStyle = '#A0826D';
                ctx.beginPath();
                ctx.arc(0, -15, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Snout
                ctx.fillStyle = '#C9B8A8';
                ctx.fillRect(-8, -8, 16, 12);
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-6, -18, 4, 0, Math.PI * 2);
                ctx.arc(6, -18, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-6, -18, 2, 0, Math.PI * 2);
                ctx.arc(6, -18, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(0, -8, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Ears
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.moveTo(-10, -28);
                ctx.lineTo(-6, -35);
                ctx.lineTo(-2, -28);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(2, -28);
                ctx.lineTo(6, -35);
                ctx.lineTo(10, -28);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function update() {
                if (!gameRunning) return;

                // Background
                const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F6FF');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

                // Clouds
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                for (let i = 0; i < 5; i++) {
                    const y = (i * 150 - cameraY / 2) % gameCanvas.height;
                    ctx.beginPath();
                    ctx.arc(50 + i * 100, y, 30, 0, Math.PI * 2);
                    ctx.arc(80 + i * 100, y, 35, 0, Math.PI * 2);
                    ctx.arc(110 + i * 100, y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Physics
                wolf.velocityY += 0.5; // gravity
                wolf.x += wolf.velocityX;
                wolf.y += wolf.velocityY;

                // Wrap around screen
                if (wolf.x < -20) wolf.x = gameCanvas.width + 20;
                if (wolf.x > gameCanvas.width + 20) wolf.x = -20;

                // Update camera
                if (wolf.y < gameCanvas.height / 2) {
                    cameraY = wolf.y - gameCanvas.height / 2;
                }

                // Check if wolf reached new height
                if (wolf.y < highestY) {
                    score += Math.floor((highestY - wolf.y) / 10);
                    highestY = wolf.y;
                    gameScore.textContent = `Score: ${score}`;
                }

                // Draw and update platforms
                for (let i = platforms.length - 1; i >= 0; i--) {
                    const platform = platforms[i];
                    
                    if (platform.type === 'moving') {
                        platform.x += platform.direction * 2;
                        if (platform.x < 0 || platform.x > gameCanvas.width - platform.width) {
                            platform.direction *= -1;
                        }
                    }

                    const screenY = platform.y - cameraY;
                    
                    if (screenY > gameCanvas.height + 100) {
                        platforms.splice(i, 1);
                        platforms.push({
                            x: Math.random() * (gameCanvas.width - 80),
                            y: platforms[platforms.length - 1].y - 60,
                            width: 80,
                            height: 15,
                            type: Math.random() > 0.8 ? 'moving' : 'static',
                            direction: Math.random() > 0.5 ? 1 : -1
                        });
                        continue;
                    }

                    // Draw platform
                    ctx.fillStyle = platform.type === 'moving' ? '#FF6B6B' : '#2d5f3f';
                    ctx.fillRect(platform.x, screenY, platform.width, platform.height);
                    
                    ctx.fillStyle = platform.type === 'moving' ? '#FF8E8E' : '#4a8f5f';
                    ctx.fillRect(platform.x, screenY, platform.width, platform.height / 2);

                    // Collision
                    if (wolf.velocityY > 0 &&
                        wolf.y + 20 >= platform.y &&
                        wolf.y + 20 <= platform.y + platform.height &&
                        wolf.x >= platform.x - 20 &&
                        wolf.x <= platform.x + platform.width + 20) {
                        wolf.velocityY = -12;
                    }
                }

                drawWolf();

                // Game over
                if (wolf.y - cameraY > gameCanvas.height) {
                    gameOver();
                    return;
                }

                // Friction
                wolf.velocityX *= 0.9;

                // Score display
                ctx.fillStyle = 'black';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Height: ${score}m`, 10, 30);

                requestAnimationFrame(update);
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`Height: ${score}m`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                const restartHandler = () => {
                    gameCanvas.removeEventListener('click', restartHandler);
                    startWolfJump();
                };
                gameCanvas.addEventListener('click', restartHandler);
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    document.removeEventListener('keydown', keyHandler);
                }
            };

            gameScore.textContent = 'Score: 0';
            update();
        }

        function startWolfCatch() {
            gameCanvas.width = gameCanvas.offsetWidth;
            gameCanvas.height = gameCanvas.offsetHeight;

            const wolf = {
                x: gameCanvas.width / 2,
                y: gameCanvas.height - 80,
                width: 50,
                height: 50,
                speed: 8
            };

            const preys = [];
            let score = 0;
            let missed = 0;
            let gameRunning = true;
            let spawnTimer = 0;
            let gameSpeed = 2;

            function mouseMoveHandler(e) {
                const rect = gameCanvas.getBoundingClientRect();
                wolf.x = e.clientX - rect.left - wolf.width / 2;
            }

            function touchMoveHandler(e) {
                e.preventDefault();
                const rect = gameCanvas.getBoundingClientRect();
                wolf.x = e.touches[0].clientX - rect.left - wolf.width / 2;
            }

            gameCanvas.addEventListener('mousemove', mouseMoveHandler);
            gameCanvas.addEventListener('touchmove', touchMoveHandler);

            function createPrey() {
                const types = ['üê∞', 'üê¶', 'üêøÔ∏è', 'ü¶Ü'];
                preys.push({
                    x: Math.random() * (gameCanvas.width - 40),
                    y: -40,
                    width: 40,
                    height: 40,
                    type: types[Math.floor(Math.random() * types.length)],
                    speed: gameSpeed + Math.random() * 2
                });
            }

            function drawWolf() {
                ctx.save();
                ctx.translate(wolf.x + wolf.width / 2, wolf.y + wolf.height / 2);
                
                // Wolf body (sitting, facing up, ready to catch)
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(-20, -10, 40, 30);
                
                // Head
                ctx.fillStyle = '#A0826D';
                ctx.beginPath();
                ctx.arc(0, -25, 18, 0, Math.PI * 2);
                ctx.fill();
                
                // Snout (pointing up)
                ctx.fillStyle = '#C9B8A8';
                ctx.fillRect(-10, -20, 20, 15);
                
                // Eyes (looking up)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-7, -30, 5, 0, Math.PI * 2);
                ctx.arc(7, -30, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-7, -32, 3, 0, Math.PI * 2);
                ctx.arc(7, -32, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Nose
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(0, -18, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouth (excited)
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, -15);
                ctx.quadraticCurveTo(0, -12, 6, -15);
                ctx.stroke();
                
                // Ears
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                ctx.moveTo(-12, -38);
                ctx.lineTo(-8, -48);
                ctx.lineTo(-4, -38);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(4, -38);
                ctx.lineTo(8, -48);
                ctx.lineTo(12, -38);
                ctx.closePath();
                ctx.fill();
                
                // Paws reaching up
                ctx.fillStyle = '#6B5345';
                ctx.fillRect(-22, -5, 8, 15);
                ctx.fillRect(14, -5, 8, 15);
                
                ctx.restore();
            }

            function update() {
                if (!gameRunning) return;

                // Background
                ctx.fillStyle = '#90EE90';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                
                // Grass pattern
                ctx.fillStyle = '#7CB77C';
                for (let i = 0; i < 20; i++) {
                    ctx.fillRect(i * 50, gameCanvas.height - 60, 30, 60);
                }

                // Spawn prey
                spawnTimer++;
                if (spawnTimer > 60 - score / 2) {
                    createPrey();
                    spawnTimer = 0;
                }

                // Update and draw prey
                for (let i = preys.length - 1; i >= 0; i--) {
                    const prey = preys[i];
                    prey.y += prey.speed;

                    // Draw prey
                    ctx.font = '40px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(prey.type, prey.x + prey.width / 2, prey.y + prey.height);

                    // Check collision
                    if (prey.x < wolf.x + wolf.width &&
                        prey.x + prey.width > wolf.x &&
                        prey.y < wolf.y + wolf.height &&
                        prey.y + prey.height > wolf.y) {
                        preys.splice(i, 1);
                        score++;
                        gameScore.textContent = `Score: ${score} | Missed: ${missed}`;
                        
                        if (score % 5 === 0) {
                            gameSpeed += 0.5;
                        }
                        continue;
                    }

                    // Check if missed
                    if (prey.y > gameCanvas.height) {
                        preys.splice(i, 1);
                        missed++;
                        gameScore.textContent = `Score: ${score} | Missed: ${missed}`;
                        
                        if (missed >= 10) {
                            gameOver();
                            return;
                        }
                    }
                }

                drawWolf();

                // Display stats
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Caught: ${score}`, 10, 30);
                ctx.fillText(`Missed: ${missed}/10`, 10, 60);

                requestAnimationFrame(update);
            }

            function gameOver() {
                gameRunning = false;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvas.width / 2, gameCanvas.height / 2 - 20);
                ctx.font = '24px Arial';
                ctx.fillText(`You caught ${score} prey!`, gameCanvas.width / 2, gameCanvas.height / 2 + 20);
                ctx.fillText('Click to restart', gameCanvas.width / 2, gameCanvas.height / 2 + 60);
                
                const restartHandler = () => {
                    gameCanvas.removeEventListener('click', restartHandler);
                    startWolfCatch();
                };
                gameCanvas.addEventListener('click', restartHandler);
            }

            currentGame = {
                stop: () => {
                    gameRunning = false;
                    gameCanvas.removeEventListener('mousemove', mouseMoveHandler);
                    gameCanvas.removeEventListener('touchmove', touchMoveHandler);
                }
            };

            gameScore.textContent = 'Score: 0 | Missed: 0';
            update();
        }

        function displayHistory() {
            if (savedConversations.length === 0) {
                historyList.innerHTML = '<p style="text-align:center;color:var(--text-secondary);padding:20px;">No saved conversations yet.</p>';
                return;
            }
            historyList.innerHTML = savedConversations.map((conv, i) => `
                <div style="padding:15px;margin:10px 0;background:rgba(26,77,46,0.1);border-left:4px solid #1a4d2e;border-radius:5px;cursor:pointer;" onclick="loadConversation(${i})">
                    <div style="font-weight:600;color:var(--text-primary);margin-bottom:5px;">${conv.title}</div>
                    <div style="font-size:14px;color:var(--text-secondary);">${conv.preview}</div>
                </div>
            `).join('');
        }

        window.loadConversation = (i) => {
            const conv = savedConversations[i];
            conversationHistory = conv.messages;
            chatBox.innerHTML = '';
            conv.messages.forEach(msg => addMessage(msg.content, msg.role === 'user' ? 'user-msg' : 'assistant-msg'));
            historyModal.classList.remove('active');
        };

        function saveConversation() {
            if (conversationHistory.length < 2) return;
            savedConversations.unshift({
                title: new Date().toLocaleString(),
                preview: conversationHistory[0].content.substring(0, 50) + '...',
                messages: [...conversationHistory],
                timestamp: Date.now()
            });
            if (savedConversations.length > 20) savedConversations = savedConversations.slice(0, 20);
            localStorage.setItem('wolfConversations', JSON.stringify(savedConversations));
        }

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            languageSelect.addEventListener('change', () => recognition.lang = languageSelect.value);
            recognition.lang = languageSelect.value;

            recognition.onstart = () => {
                isListening = true;
                statusBar.textContent = 'üê∫ I\'m listening!';
                statusBar.className = 'status-bar listening';
                visualizer.classList.add('active');
            };

            recognition.onresult = (event) => {
                if (synthesis.speaking) return;
                let interim = '', final = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) final += transcript;
                    else interim += transcript;
                }
                if (interim) showInterim(interim);
                if (final && final.trim()) {
                    if (interimElement) {
                        interimElement.remove();
                        interimElement = null;
                    }
                    addMessage(final, 'user-msg');
                    recognition.stop();
                    getAIResponse(final);
                }
            };

            recognition.onerror = (event) => {
                if (event.error === 'not-allowed') {
                    alert('‚ö†Ô∏è Microphone access denied! Please allow access and refresh.');
                    resetApp();
                } else if (event.error === 'audio-capture') {
                    alert('‚ùå Microphone error! Check your device.');
                    resetApp();
                }
            };

            recognition.onend = () => {
                visualizer.classList.remove('active');
                if (isListening && !synthesis.speaking) {
                    setTimeout(() => {
                        if (isListening && !synthesis.speaking) {
                            try { recognition.start(); } catch (e) {}
                        }
                    }, 100);
                }
            };
        }

        function showInterim(text) {
            if (emptyMsg && emptyMsg.parentNode) emptyMsg.remove();
            if (!interimElement) {
                interimElement = document.createElement('div');
                interimElement.className = 'message interim-msg';
                chatBox.appendChild(interimElement);
            }
            interimElement.textContent = text + '...';
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function addMessage(text, className) {
            if (emptyMsg && emptyMsg.parentNode) emptyMsg.remove();
            const msg = document.createElement('div');
            msg.className = 'message ' + className;
            msg.textContent = text;
            chatBox.appendChild(msg);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        async function getAIResponse(userInput) {
            statusBar.textContent = 'ü§ñ Thinking...';
            statusBar.className = 'status-bar thinking';

            conversationHistory.push({ role: 'user', content: userInput });

            const lang = languageSelect.value;
            const langName = languageNames[lang];
            const personality = personalities[personalitySelect.value];
            
            // Build system prompt with specific language instructions
            let systemPrompt = personality;
            
            if (lang.includes('-NG')) {
                // Nigerian languages need explicit instructions
                systemPrompt += languageInstructions[lang];
            } else if (lang !== 'en-US' && lang !== 'en-GB') {
                systemPrompt += ` Always respond in ${langName}. Do not use English.`;
            }

            try {
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: modelSelect.value,
                        messages: [{ role: 'system', content: systemPrompt }, ...conversationHistory],
                        temperature: 0.8,
                        max_tokens: 150
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    const aiResponse = data.choices[0].message.content;
                    conversationHistory.push({ role: 'assistant', content: aiResponse });
                    addMessage(aiResponse, 'assistant-msg');
                    if (!isMuted) speak(aiResponse);
                    if (conversationHistory.length % 4 === 0) saveConversation();
                } else throw new Error('Invalid response');
            } catch (error) {
                console.error('AI Error:', error);
                conversationHistory.pop();
                const errMsg = "I encountered a hiccup. Try again?";
                addMessage(errMsg, 'assistant-msg');
                if (!isMuted) speak(errMsg);
            }
        }

        function speak(text) {
            if (isMuted) {
                setTimeout(() => {
                    if (isListening) {
                        statusBar.textContent = 'üê∫ I\'m listening...';
                        statusBar.className = 'status-bar listening';
                        try { recognition.start(); } catch (e) {}
                    } else resetApp();
                }, 500);
                return;
            }

            statusBar.textContent = 'üê∫ Speaking...';
            statusBar.className = 'status-bar speaking';
            synthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.95;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            const lang = languageSelect.value;
            const voices = synthesis.getVoices();
            const langVoices = voices.filter(v => v.lang.startsWith(lang.split('-')[0]));
            const voice = langVoices.find(v => v.name.includes('Natural') || v.name.includes('Enhanced')) || langVoices[0] || voices.find(v => v.lang.startsWith('en'));
            if (voice) {
                utterance.voice = voice;
                utterance.lang = lang;
            }

            utterance.onstart = () => {
                if (recognition && isListening) {
                    try { recognition.stop(); } catch (e) {}
                }
            };

            utterance.onend = () => {
                setTimeout(() => {
                    if (isListening) {
                        statusBar.textContent = 'üê∫ I\'m listening...';
                        statusBar.className = 'status-bar listening';
                        try { recognition.start(); } catch (e) {}
                    } else resetApp();
                }, 500);
            };

            synthesis.speak(utterance);
        }

        function resetApp() {
            isListening = false;
            startButton.style.display = 'block';
            stopButton.style.display = 'none';
            statusBar.textContent = 'üê∫ Ready when you are!';
            statusBar.className = 'status-bar';
            visualizer.classList.remove('active');
            if (microphone) microphone.disconnect();
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            if (conversationHistory.length > 0) saveConversation();
        }

        startButton.addEventListener('click', async () => {
            if (!recognition) {
                alert('‚ùå Speech recognition not supported! Use Chrome, Edge, or Safari.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });

                startButton.style.display = 'none';
                stopButton.style.display = 'block';
                isListening = true;
                recognition.start();

                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                analyser.fftSize = 256;

                const dataArray = new Uint8Array(analyser.frequencyBinCount);

                function draw() {
                    if (!isListening) return;
                    requestAnimationFrame(draw);
                    analyser.getByteFrequencyData(dataArray);
                    const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    volumeBar.style.width = Math.min((avg / 255) * 200, 100) + '%';
                }
                draw();
            } catch (err) {
                console.error('Microphone error:', err);
                if (err.name === 'NotAllowedError') {
                    alert('‚ö†Ô∏è Microphone access denied!\n\nPlease:\n1. Click lock icon in address bar\n2. Allow microphone\n3. Refresh and try again');
                } else if (err.name === 'NotFoundError') {
                    alert('‚ùå No microphone found! Please connect one.');
                } else {
                    alert('‚ùå Microphone error: ' + err.message);
                }
                resetApp();
            }
        });

        stopButton.addEventListener('click', () => {
            isListening = false;
            if (recognition) recognition.stop();
            if (synthesis.speaking) synthesis.cancel();
            resetApp();
        });

        if (synthesis.onvoiceschanged !== undefined) {
            synthesis.onvoiceschanged = () => console.log('Voices loaded:', synthesis.getVoices().length);
        }

        console.log('‚úÖ Wolf Audio Chat ready!');
    </script>
</body>
</html>